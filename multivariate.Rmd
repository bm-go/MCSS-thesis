---
title: "Bivariate analysis"
author: "bmck"
date: "2025-06-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Purpose

This code will do exploratory analysis between the variables related to trust and other demographic factors: 

The workflow is: 
  - Call summarised dataset
  - create functions to summarise and analyse
  - Run the functions to look at trends for each trust variable. 
  
The order of trust variable presentation is: xxxx, yyyy

The variables included will be: 

```{r}
### CALL THE SCRIPT TO CREATE SUMMARY DATAFRAME
```


### Libraries

```{r}
library(DataExplorer)
library(survey)
library(purrr)
library(dplyr)

```


### Check for low response rates to remove initial variables 

Use GB only to check at this stage. as this is our focus anyway. 

Check sociodemographic variables:

```{r}
# check overall missing 
ess_data |> 
  filter(cntry == "GB") |> 
  plot_missing()

# select all variables with over 50% missing values
missing50plus <- ess_data |> 
  filter(cntry == "GB") |> 
  select(where(~ mean(is.na(.)) * 100 > 50)) |> names()

print(missing50plus)

# make sure we don't remove weights
missing50plus <- missing50plus[!(missing50plus %in% c("psu", "stratum"))]

## remove these values:
ess_data <- ess_data |> 
  select(-missing50plus)
```

Remove variables with high missing values in our key waves. 

```{r}
## check for missing in key rounds of data:
ess_data |> 
  select(-psu, -stratum) |> 
  filter(cntry == "GB",
         essround %in% c(6,7,8)) |> 
  plot_missing()


```


#### Political variables 

```{r}
## check overall response rates
ess_data |> 
  filter(cntry == "GB") |> 
  select(
    vote, # Voted last national election (Yes/No)
    prtvtbgb,  # Party voted for in last national election
    prtclbgb,  # Which party feel closer to, United Kingdom
    prtdgcl,  # How close does the repondent feel to the party party from 'prtclbgb'
    lrscale, # left right political scale 
    polintr # level of political interest
) |> plot_missing()


# we see some variables on political party were only asked in waves 7 and 8 with high NA values anyway. 
ess_data |> filter(cntry == "GB") |> 
  count(essround, prtclbgb) |> 
  pivot_wider(names_from = prtclbgb, values_from = n)

```

We retain political interest, voted in last election and left right scale. 

```{r}
ess_data |> 
  select(-prtvtbgb, -prtclbgb, - prtdgcl)

# specify our remaining political variables for calling later:
polit_vars <- c("vote", "lrscale", "polintr")
```

Check multicollinearity

We see these are all valid. Voting is more correlated with voting. 

```{r}

cor_matrix <- cor(ess_data |> 
                  select(vote, lrscale, polintr),
                  use = "pairwise.complete.obs")

corrplot(cor_matrix, method = "color", type = "upper", 
         addCoef.col = "black", tl.col = "black",
         col = colorRampPalette(c("blue", "white", "red"))(200))
```

### income and education

```{r}
# identify vars
inc_edu_vars <- c(
  "eisced",  # Highest level of education of respondent
    "pdwrk",  # In paid work
    "hinctnta", # Household's total net income, all sources (reported in deciles)
    "hincfel") # Feeling about household's income nowadays - financial stress


# plot correlations:

```


#### Satisfaction variables

Set the variables, plot missing and 
```{r}
satis_vars <- c(
    # satisfaction with life and country
    "stflife", # How satisfied with life as a whole
    "stfdem", # How satisfied with the way democracy works in country
    "stfeco", # How satisfied with present state of economy in country
    "stfgov", # How satisfied with the national government
    "stfedu", # State of education in country nowadays
    "stfhlth" # State of health services in country nowadays
)

cor_matrix <- cor(ess_data |> 
                  filter(cntry == "GB") |> 
                  select(satis_vars),
                  use = "pairwise.complete.obs")

corrplot(cor_matrix, method = "color", type = "upper", 
         addCoef.col = "black", tl.col = "black",
         col = colorRampPalette(c("blue", "white", "red"))(200))


ess_data |> filter(cntry == "GB") |> select(satis_vars) |> plot_histogram()
```

## Immigration variables:

```{r}
immig_vars <- c(
    "imsmetn",  #Allow many/few immigrants of same race/ethnic group as majority
    "imdfetn",  #Allow many/few immigrants of different race/ethnic group from majority
    "impcntr",  #Allow many/few immigrants from poorer countries outside Europe
    "imbgeco",  #Immigration bad or good for country's economy
    "imueclt",  #Country's cultural life undermined or enriched by immigrants
    "imwbcnt")  #Immigrants make country worse or better place to live

cor_matrix <- cor(ess_data |> 
                  filter(cntry == "GB") |> 
                  select(immig_vars),
                  use = "pairwise.complete.obs")

corrplot(cor_matrix, method = "color", type = "upper", 
         addCoef.col = "black", tl.col = "black",
         col = colorRampPalette(c("blue", "white", "red"))(200))


ess_data |> filter(cntry == "GB") |> select(immig_vars) |> plot_histogram()

# plot just overall attitudes. We see they have increased overall which is strange (unweighted data)
ess_data |> 
  filter(cntry == "GB") |> 
  group_by(essround) |> 
  summarise(avg_immig_att = mean(imwbcnt, na.rm = TRUE)) |> 
  ggplot()+
  geom_line(aes(x=essround, y=avg_immig_att))

```

Quite high correlations, we see that there are many 5/10 responses here. Large modal value. This is likely people not wanting to appear racist. 
We will continue with "imwbcnt" - Immigrants make country worse or better place to live. 
We will group this as yes, no, moderate but not focus on extremes. This will be hard to exploit as many people appear to be hiding their true value.  


### Reduce dataset 

```{r}

```

## Compare trends in trust variables: 

This analysis will happen with all of the round 7 data to establish our baseline. 

```{r}
ess_gb_r7 <- ess_data |> 
  filter(essround == 7,
         cntry == "GB")
```

Now we compare 

## Trust in politicians: 

Compared to political variables: 

```{r}
## calculate summaries with error bars
ess_gb_r7 |> 
  select(trust_politicians, polit_vars) |> names()

ggplot(ess_r7, 
       aes(x = factor(essround), y = wt_avg_mean, 
           group = trust_variable, colour = trust_variable)) +  # group=1 ensures lines connect across points
  geom_line(size = 1) +  # Line for the trend
  geom_point(size = 1.5) +  # Points for each mean
  geom_errorbar(aes(ymin = ci_l, ymax = ci_u),  # Error bars using CI bounds
                width = 0.5,  # Width of the error bar caps
                color = "gray") +  
  labs(title = "Mean Trust in UK by variable, ESS round 1-11",
       subtitle = "With 95% Confidence Intervals",
       x = "ESS Round",
       y = "Mean Trust (/10 with CI included)") +
  theme_minimal()


boxplot(ess_gb_r7$trust_politicians, 
        ess_gb_r7[polit_vars])
ess_data |> 
  group_by(vote, lrscale, polintr) |> 
  summarise(
    mean_trust = mean(trust_politicians, na.rm = TRUE),
    sd_trust = sd(trust_politicians, na.rm = TRUE),
    n = n(),
    .groups = "drop"
  ) |> 
  mutate(
    se_trust = sd_trust / sqrt(n),  # Standard error
    lower_ci = mean_trust - 1.96 * se_trust,  # 95% CI lower bound
    upper_ci = mean_trust + 1.96 * se_trust   # 95% CI upper bound
  ) |> 
  ggplot(aes(x = lrscale, y = mean_trust, color = vote)) +
  geom_point(size = 3) +  # Add points
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2) +  # Error bars
  facet_wrap(~polintr) +  # Facet by political interest
  labs(x = "Left-Right Scale", y = "Mean Trust in Politicians", color = "Vote") +
  theme_minimal()


```

```{r}
library(sjlabelled)

# extract the label values: 
ess_gb_r7 |> 
  select(trust_politicians, anweight, polit_vars) |> 
  mutate(across(all_of(polit_vars), haven::as_factor, .names = "{.col}_label"))

get_labels(ess_gb_r7$vote)
pivot_longer(cols = c(vote, lrscale, polintr), 
               names_to = "grouping_var", values_to = "trust_value") |> 
  group_by(grouping_var, trust_value) |> 
  summarise(
    mean_trust = mean(trust_politicians, na.rm = TRUE),
    sd_trust = sd(trust_politicians, na.rm = TRUE),
    n = n(),
    .groups = "drop"
  ) |> 
  mutate(
    se_trust = sd_trust / sqrt(n),  # Calculate Standard Error
    lower_ci = mean_trust - 1.96 * se_trust,  # 95% Confidence Interval (Lower)
    upper_ci = mean_trust + 1.96 * se_trust   # 95% Confidence Interval (Upper)
  )

# Step 2: Create point plot with error bars
ggplot(summary_data, aes(x = factor(group_value), y = mean_trust, color = grouping_var)) +
  geom_point(size = 3, position = position_dodge(width = 0.4)) +  # Positioning to avoid overlap
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2, position = position_dodge(width = 0.4)) +
  labs(x = "Group Levels", y = "Mean Trust in Politicians", color = "Grouping Variable") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(ess_gb_r7, aes(x = trust_politicians, fill = forcats::as_factor(vote))) +
  geom_bar() +
  facet_wrap(~ forcats::as_factor(vote)) +  # Creates separate plots for each vote option
  labs(x = "Trust in Politicians", fill = "Vote Outcome") +
  theme_minimal()

ess_gb_r7 |> 
  mutate(across(where(is.labelled), sjlabelled::as_factor))  |> 
  ggplot(aes(x = trust_politicians, fill = vote)) +
  geom_bar() +
  facet_wrap(~ vote) +  # Split by vote outcome
  labs(x = "Trust in Politicians", fill = "Vote Outcome") +
  theme_minimal()

```


```{r}

ess_data |> 
  

```


### Select our final demographic variables to calculate conditional means. 

```{r}

# choose variables for demographics:
demog_vars <- c(        
  ## ID and weights
    "essround",
    "cntry",
    "anweight",

    # trust variables (local and EU parliament only)
    "trust_europ",
    "trust_parliament",

    # some demographic variables
    "gndr",  # Gender
    "agea",  # Calculated age of respondent

      # income + education
    "eisced",  # Highest level of education of respondent
    "hincfel", # Feeling about household's income nowadays - financial stress
        # citizenship/ethnicity
    "blgetmg", # Belong to minority ethnic group in country
        # location
    "domicil", # type of area 5pt scale - A big city, Suburbs or outskirts, town or small city, village, countryside
        # health 
    "hlthhmp", # Hampered in daily activities by illness/disability/infirmity/mental problem


    # political identifiers
    "lrscale", # left right political scale 
    "polintr", # level of political interest
    
    # satisfaction with life and country
    "stflife", # How satisfied with life as a whole
    "stfeco", # How satisfied with present state of economy in country

    
    # additional variables from literature
        # media consumption - political specific? 
    "tvpol", # TV watching, news/politics/current affairs on average weekday
        # immigration
    "imwbcnt" #Immigrants make country worse or better place to live
)

# now limit to only variables of interest
ess_bivar_local_gb <- ess_data |> 
  filter(cntry == "GB",
         essround %in% c(5,6,7,8)) |> 
  select(any_of(demog_vars))


```

## to clean variables:

agea - to standard age groups 
eisced - combine to fewer groups. 
domicil - to 4pt scale - combine country data
hlthhmp - physical or mental disability, combine both yes categories.
polintr - binary yes/no (from 4pt scale)
tvpol - adjust to be >1hr a day average or no/low binary. 


Regroup all the 10pt scale variables to categorical - test 3pt and 5pt
  3pt = 0-3, 4-6, 7-10
  5pt = 0-1, 2-3, 4-6, 7-8, 9-10

10pt vars:
lrscale - to 3pt scale->  left (0-3), moderate (4-6) and right (7-10) 

Sample code on how to easily combine levels with fct_collapse

```{r}
# usoc_online <- usoc3 |> 
#   mutate(across(socialmedia_look:online_streaming, 
#          ~fct_collapse(.,
#                     "NA" = c("don't know", "inapplicable", "proxy", "refusal"),
#                     "Never" = "never",
#                     "Rarely" = c("less than once a month", "once a month"),
#                     "At least monthly" = "several times a month",
#                     "At least weekly" = "several times a week",
#                     "Daily" = "every day"
#                     ))) |> 
#   mutate(across(socialmedia_look:online_streaming, 
#            ~ na_if(., "NA")))  # Convert the "NA" level to true NA (can't be done directly above)
# 
# 
# #recode the online variables so they are an ordered factor for plotting:
# usoc_online <- usoc_online |> 
#   mutate(across(socialmedia_look:online_streaming,
#                 ~fct_relevel(.,
#                              "Never", "Rarely", "At least monthly", "At least weekly", "Daily")))


```

1. Use function to tidy all 10pt scale variables (into 3pt scales) 

```{r}
#function to create high/low variables for each: 
convert_10pt_3pt <- function(var_10pt) {
  factor(
    case_when(
      var_10pt < 4 ~ "Low",
      between(var_10pt, 4, 6) ~ "Moderate",
      between(var_10pt, 7, 10) ~ "High", # use range to avoid any poorly coded 77/88/99 values being included
      TRUE ~ NA #account for true NAs from no response
  ),
  levels = c("High","Moderate","Low",  NA))
}


```


First, convert all to factor, this will give us the text labels too. 

```{r}

# add on recoded variables that are cleaned.
ess_bivar_local_gb <- ess_bivar_local_gb |> 
    mutate(
      # create age groupings
      age_rec = factor(case_when(agea <20 ~ "<20",
                             between(agea, 20, 29) ~ "20-29",
                             between(agea, 30, 44) ~ "30-44",
                             between(agea, 45, 64) ~ "45-64", 
                             agea >= 65 ~ ">=65",
                             TRUE ~ NA),
                          levels = c("<20", "20-29", "30-44", "45-64", ">=65")),
      
      # recode as factor for labels but these 3 are unchanged on scales
      gender = as_factor(gndr),
      income_stress = as_factor(hincfel),
      ethnic_minority = as_factor(blgetmg),

      # create education factor levels
      educ_level = factor(case_when(between(eisced, 1, 2) ~ "Lower secondary", # 1 or 2 = low (lower secondary)
                             between(eisced, 3, 4) ~ "Upper secondary", # 3 or 4 = medium (upper secondary)
                             between(eisced, 5, 7) ~ "Tertiary", # 5, 6 or 7 = high (vocational/tertiary)
                             TRUE ~ NA),
                          levels = c("Lower secondary", "Upper secondary", "Tertiary")),

      # region type - just group country level data, so we have a 4pt scale. 
      area_type = fct_collapse(as_factor(domicil), 
                                "Country" = c("Country village", "Farm or home in countryside")),

      # health - physical/mental limitation flag: 
      health_disability = factor(case_when(between(hlthhmp, 1,2) ~ "Yes",
                                           hlthhmp == 3 ~ "No",
                                           TRUE ~ NA)),
      # left right scale
      left_right =   factor(case_when(lrscale < 4 ~ "Left (0-3)",
                                      between(lrscale, 4, 6) ~ "Moderate (4-6)",
                                      between(lrscale, 7, 10) ~ "Right (7-10)",
                                      TRUE ~ NA)), #account for true NAs from no response

      # convert political interst to binary 
      polintr_binary = case_when(polintr %in% c(1,2) ~ "Yes",
                                    polintr %in% c(3,4) ~ "No",
                                    TRUE ~ NA_character_),
      
      # convert satisfactions from 10pt to 3pt scale
      life_sat = convert_10pt_3pt(stflife), 
      econ_sat = convert_10pt_3pt(stfeco),
      
      #attitudes to immigration - make country a better place 
      immig_support = convert_10pt_3pt(imwbcnt),
      
      # binary political tv viewership - over 1hr a day
      high_pol_tv = case_when(tvpol %in% c(0,1,2) ~ "No",
                              tvpol %in% c(3,4,5,6,7) ~ "Yes",
                              TRUE ~ NA))
      

```


Now we remove our additional columns: 

```{r}
ess_bivar <- 
  ess_bivar_local_gb |> select(
  essround,
  cntry, 
  anweight, 
  trust_europ,
  trust_parliament,
  # demog vars: 
  gender, # gender - binary
  age_rec, # age recoded - 5pt 
  educ_level, # education recoded - 3pt 
  income_stress, # income stress level - 4pt
  ethnic_minority, # minority ethnic group - binary
  area_type, # regional description - 4pt
  health_disability, # physical/mental disability - binary
  left_right, ## recoded - 3pt 
  polintr_binary, # recoded - 3pt
  life_sat, # recoded - 3pt
  econ_sat, # recoded - 3pt
  immig_support, # recoded - 3pt 
  high_pol_tv) # recoded - binary >1hr

```

Calculate weighted averages for trust in European parliament. 

```{r}
# calculate averages across all waves to get an idea and standardise later:
overall_eu_trst_r5678 <- ess_bivar_local_gb |> 
  as_survey_design(ids = 1, weights = anweight) |> 
  filter(!is.na(trust_europ)) |> 
  summarise(mean_trust = survey_mean(trust_europ, vartype = "ci"))

print(overall_eu_trst_r5678)

# pull the avg for standardising.
overall_avg <- overall_eu_trst_r5678$mean_trust[1]
```

## Create weighted conditional means. 

Now we calculate all of the means within groups. 

This loop was mostly AI but runs well to go through each column and return the mean for each level, standard error and confidence intervals. 

```{r}
# setup survey design
simple_design <- ess_bivar |> 
  as_survey_design(ids = 1, weights = anweight)

# create list of our demographic variables
demog_vars <- ess_bivar |> select(gender:high_pol_tv) |> names()
demog_vars


# 
all_trust_eu_summary <- 
  map_dfr(demog_vars, function(dv) {
    # 1) build a one‐sided formula for svyby: ~gender, ~age_group, etc.
    by_fml <- as.formula(paste0("~", dv)) 
    
    # 2) call svyby() for trust_europ
    tmp <- svyby(
      formula  = ~trust_europ,
      by       = by_fml,
      design   = simple_design,
      FUN      = svymean,
      vartype  = c("ci", "se"),
      ci.level = 0.95,
      na.rm    = TRUE
    )
    
    # 3) Tidy column names & capture the “level” for this dv
    tmp %>%
      rename(
        mean     = trust_europ,
        ci_low   = ci_l,
        ci_high  = ci_u
      ) %>%
      mutate(
        demog_var = dv,
        level    = as.character(.data[[dv]])
      ) %>%
      select(demog_var, level, mean, se, ci_low, ci_high)
  })

print(all_trust_eu_summary)

```

Now plot with the confidence intervals  

```{r}
ggplot(all_trust_eu_summary,
       aes(x = mean,
           y = fct_reorder(paste0(demog_var, ": ", level), mean))) +
  geom_point(size = 2, colour = "steelblue") +
  geom_errorbarh(aes(xmin = ci_low, xmax = ci_high),
                 height = 0, colour = "gray50") +
#  facet_grid(demog_var ~ ., scales = "free_y", space = "free_y") +
  labs(
    x = "Weighted mean of Trust in EU Parliament",
    y = NULL,
    title = "Conditional Mean of Trust by Demographic Groups",
    subtitle = "Point estimates ± 95% CI"
  ) +
  theme_minimal() +
  theme(
    strip.text.y      = element_text(angle = 0, face = "bold"),
    axis.text.y       = element_text(size = 10),
    panel.spacing.y   = unit(0.5, "lines")
  )+ geom_vline(xintercept = overall_avg)


```

Now grouped by the actual demographic variables too: 
```{r}

ggplot(all_trust_eu_summary,
       aes(x = mean,
           y = fct_reorder(level, mean))) +
  geom_point(size = 2, colour = "steelblue") +
  geom_errorbarh(aes(xmin = ci_low, xmax = ci_high),
                 height = 0, colour = "gray50") +
  facet_grid(demog_var ~ ., scales = "free_y", space = "free_y") +
  labs(
    x = "Weighted mean of Trust in EU Parliament",
    y = NULL,
    title = "Conditional Mean of Trust in EU, by Demographic Groups",
    subtitle = "Point estimates ± 95% CI"
  ) +
  theme_minimal() +
  theme(
    strip.text.y      = element_text(angle = 0, face = "bold"),
    axis.text.y       = element_text(size = 10),
    panel.spacing.y   = unit(0.5, "lines")
  ) + 
  geom_vline(xintercept = overall_avg)+
    scale_y_discrete(expand = expansion(add = c(1, 1)),
                   position = "left")



```


```{r}
# ensure you calculated the overall average in the data above. 
standardized_trust_eu <- all_trust_eu_summary |> 
  mutate(std_mean = mean - overall_avg,
         std_ci_low = ci_low - overall_avg,
         std_ci_high = ci_high - overall_avg)
```

And plot the standardised results

```{r}
ggplot(standardized_trust_eu,
       aes(x = std_mean,
           y = fct_reorder(paste0(demog_var, ": ", level), mean))) +
  geom_point(size = 2, colour = "steelblue") +
  geom_errorbarh(aes(xmin = std_ci_low, xmax = std_ci_high),
                 height = 0, colour = "gray50") +
  facet_grid(demog_var ~ ., scales = "free_y", space = "free_y") +
  labs(
    x = "Standardised mean of Trust in EU Parliament",
    y = NULL,
    title = "Standardised Mean of Trust in EU by Demographic Groups",
    subtitle = "Point estimates ± 95% CI"
  ) +
  theme_minimal() +
  theme(
    strip.text.y      = element_text(angle = 0, face = "bold"),
    axis.text.y       = element_text(size = 10),
    panel.spacing.y   = unit(0.5, "lines")
  )+
  geom_vline(xintercept = 0)


```

### Trust in local (UK) Parliament by demographics

Repeat the process for trust in local parliament. 

```{r}
# setup survey design
simple_design <- ess_bivar |> 
  as_survey_design(ids = 1, weights = anweight)

# create list of our demographic variables
demog_vars <- ess_bivar |> select(gender:high_pol_tv) |> names()
demog_vars


# local parliament loop through each demogrpahic then add on
all_trust_local_summary <- 
  map_dfr(demog_vars, function(dv) {
    # 1) build a one‐sided formula for svyby: ~gender, ~age_group, etc.
    by_fml <- as.formula(paste0("~", as_factor(dv))) 
    
    # 2) call svyby() for trust_europ
    tmp <- svyby(
      formula  = ~trust_parliament,
      by       = by_fml,
      design   = simple_design,
      FUN      = svymean,
      vartype  = c("ci", "se"),
      ci.level = 0.95,
      na.rm    = TRUE
    )
    
    # 3) Tidy column names & capture the “level” for this dv
    tmp %>%
      rename(
        mean     = trust_parliament,
        ci_low   = ci_l,
        ci_high  = ci_u
      ) %>%
      mutate(
        demog_var = dv,
        level    = as.character(.data[[dv]])
      ) %>%
      select(demog_var, level, mean, se, ci_low, ci_high)
  })

print(all_trust_local_summary)
```

PLot the values for local parliament: 

```{r}
ggplot(all_trust_local_summary,
       aes(x = mean,
           y = fct_reorder(paste0(demog_var, ": ", level), mean))) +
  geom_point(size = 2, colour = "steelblue") +
  geom_errorbarh(aes(xmin = ci_low, xmax = ci_high),
                 height = 0, colour = "gray50") +
#  facet_grid(demog_var ~ ., scales = "free_y", space = "free_y") +
  labs(
    x = "Weighted mean of Trust in Parliament",
    y = NULL,
    title = "Conditional Mean of Trust in UK Parliament by Demographic Groups",
    subtitle = "Point estimates ± 95% CI"
  ) +
  theme_minimal() +
  theme(
    strip.text.y      = element_text(angle = 0, face = "bold"),
    axis.text.y       = element_text(size = 10),
    panel.spacing.y   = unit(0.5, "lines")
  )+ 
  geom_vline(xintercept = overall_avg_local)


```

And unordered data, grouped by variable:

```{r}
ggplot(all_trust_local_summary,
       aes(x = mean,
           y = fct_reorder(level, mean))) +
  geom_point(size = 2, colour = "steelblue") +
  geom_errorbarh(aes(xmin = ci_low, xmax = ci_high),
                 height = 0, colour = "gray50") +
  facet_grid(demog_var~., scales = "free_y", space = "free_y") +
  labs(
    x = "Weighted mean of Trust in Parliament",
    y = NULL,
    title = "Conditional Mean of Trust in UK Parliament by Demographic Groups",
    subtitle = "Point estimates ± 95% CI"
  ) +
  theme_minimal() +
  theme(
    strip.text.y      = element_text(angle = 0, face = "bold"),
    axis.text.y       = element_text(size = 10),
    panel.spacing.y   = unit(0.5, "lines")
  )+ 
  geom_vline(xintercept = overall_avg_local)

```


#### Standaridised plots:
Standardise values

```{r}
# calculate averages across all waves to get an idea and standardise later:
overall_local_trst_r5678 <- ess_bivar_local_gb |> 
  as_survey_design(ids = 1, weights = anweight) |> 
  filter(!is.na(trust_parliament)) |> 
  summarise(mean_trust = survey_mean(trust_parliament, vartype = "ci"))

print(overall_local_trst_r5678)

# pull the avg for standardising.
overall_avg_local <- overall_local_trst_r5678$mean_trust[1]
print(overall_avg_local)
```

### Join data together: 

Combine data for euro and local parliament trust. 

```{r}

overall_demog_trust <- left_join(
  all_trust_eu_summary, all_trust_local_summary,
  by = c("demog_var", "level"),
  suffix = c(".eu", ".uk")
)

overall_demog_trust
```

##### Check correlations:

```{r}
overall_demog_trust |> 
  ggplot(aes(x = mean.eu,
             y = mean.uk))+
  geom_point(size = 2)+
  theme_minimal()+
  labs(title = "Avereage trust in EU vs UK parliament by demographic group",
       x = "Average EU Parliament trust (/10)",
       y = "Average UK Parliament trust (/10)")

cor(overall_demog_trust$mean.eu,
                 overall_demog_trust$mean.uk)
```

We see a strong positive correlation. This trend is biased as it's all trained on the same data and not independent groups. But it does show that the demographic groups generally have positive correlations with trust in UK and EU. This supports the findings of (Harteveld et al. 2013) that found EU trust is driven by local government trust. 

Plot both together: 

```{r}
ggplot(overall_demog_trust) +
  geom_point(aes(x = mean.eu,
           y = fct_reorder(level, mean.eu),
           size = 2, colour = "steelblue")) +
  geom_errorbarh(aes(xmin = ci_low.eu, xmax = ci_high.eu),
                 height = 0, colour = "gray50") +
  geom_point(aes(x = mean.uk,
           y = fct_reorder(level, mean.uk), 
           size = 2, colour = "orange")) +
  geom_errorbarh(aes(xmin = ci_low.uk, xmax = ci_high.uk),
                 height = 0, colour = "gray50") +
  #facet_grid(demog_var~., scales = "free_y", space = "free_y") +
  labs(
    x = "Weighted mean of Trust in EU/UK Parliament",
    y = NULL,
    title = "Conditional Mean of Trust in EU/UK Parliament",
    subtitle = "Point estimates ± 95% CI"
  ) +
  theme_minimal() +
  theme(
    strip.text.y      = element_text(angle = 0, face = "bold"),
    axis.text.y       = element_text(size = 10),
    panel.spacing.y   = unit(0.5, "lines")
  )
  
```

Plot with negative values for UK to show the group's values next to each other:

```{r}
# Create a modified dataset where UK values are negative (for left alignment)
plot_data <- overall_demog_trust |> 
  mutate(neg.mean.uk = -mean.uk,
         std.uk = mean.uk-overall_avg_local,
         std.uk_cilow = ci_low.uk-overall_avg_local,
         std.uk_cihigh = ci_high.uk-overall_avg_local,
         std.eu = mean.eu - overall_avg,  # Negate UK values so they appear on the left
         std.eu_cilow = ci_low.eu-overall_avg,
         std.eu_cihigh = ci_high.eu-overall_avg)

```

```{r}

# Plot
ggplot(plot_data) +
  # plot eu values
  geom_point(aes(x = mean.eu, y = fct_reorder(level, mean.eu)),
             color = "steelblue", size = 2) + # EU
  geom_errorbarh(aes(y = level, xmin = ci_low.eu, xmax = ci_high.eu),
                 color = "gray50", height = 0) +
  # plot gb values
  geom_point(aes(x = mean.uk, y = fct_reorder(level, mean.uk)),
             color = "orange", size = 2) + # UK
  geom_errorbarh(aes(y = level, xmin = ci_high.uk, xmax = ci_low.uk),
                 color = "gray50", height = 0) +
  labs(
    x = "Weighted Mean of Trust",
    y = NULL,
    title = "Trust in EU vs UK Parliament by Demographic Group",
    subtitle = "EU = Blue; UK = Orange"
  ) +
  theme_minimal() +
  facet_grid(demog_var ~ ., scales = "free_y", space = "free_y",
             switch = "y") + # For left-side placement of "strip" label 
  theme(
    strip.text.y.left = element_text(angle = 0, face = "bold", hjust = 0), 
    strip.placement = "outside", 
    axis.text.y = element_text(size = 10, hjust = 1), 
    panel.spacing.y = unit(0.5, "lines")
  ) +
  scale_y_discrete(expand = expansion(add = c(1, 1)),
                   position = "left")
```

Standardised trends for trust in UK and EU Parliament by demographic gorup  

```{r}
# Plot with standardised data to show around the same zero value
ggplot(plot_data) +
  geom_point(aes(x = std.eu, y = fct_reorder(interaction(demog_var, level), std.eu)), 
             color = "steelblue", size = 2) + # EU
  geom_errorbarh(aes(y = interaction(demog_var, level), 
                     xmin = std.eu_cilow, xmax = std.eu_cihigh), 
                 color = "gray50", height = 0) + 

  geom_point(aes(x = std.uk, y = fct_reorder(interaction(demog_var,level), std.uk)), 
             color = "orange", size = 2) + # UK
  geom_errorbarh(aes(y = interaction(demog_var, level), 
                     xmin = std.uk_cilow, xmax = std.uk_cihigh), 
                 color = "gray50", height = 0) + 

 # geom_vline(xintercept = , linetype = "dashed", color = "black") +  # Middle reference line

  labs(
    x = "Weighted Mean of Trust in UK and EU Parliament, UK R5-8",
    y = NULL,
    title = "Standardised trust in EU vs UK Parliament",
    subtitle = "Blue = EU; Orange = UK. CI ± 95%"
  ) +
  theme_minimal()+
  scale_y_discrete(expand = expansion(add = c(1, 1))) # Adds space before/after categories


```



Plot as table using stargazer 

```{r}
summary_plot_data <- plot_data |> 
  select(demog_var, level, mean.eu, se.eu, mean.uk, se.uk)

stargazer(summary_plot_data,
          type = "text",  # Use "latex" or "html" for different formats
          summary = FALSE, # Prevent summary statistics
          rownames = FALSE, # Remove row numbers
          title = "Summary Table",
          column.labels = c("Demographic Variable", "Level", "Mean EU", "SE EU", "Mean UK", "SE UK"),
          align = TRUE)
```

